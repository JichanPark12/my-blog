---
title: "Next.js로 나만의 최적화된 블로그 만들기 (with. 바이브 코딩)"
description: "Next.js 14, Shadcn UI, 그리고 커스텀 마크다운 인덱싱 시스템을 활용하여 고성능 테크 블로그를 구축한 과정을 공유합니다."
category: "tech"
tags: ["nextjs", "react", "blog", "optimization", "shadcn", "vibe-coding"]
thumbnail: "/images/blog-review-thumbnail.jpg"
---

안녕하세요! 오늘은 이 블로그를 어떻게 만들었는지에 대한 기술적인 이야기를 해보려고 합니다.
단순히 Next.js 템플릿을 가져다 쓰는 것이 아니라, 직접 마크다운 처리 로직을 구현하고 성능을 극한으로 끌어올리는 과정이 꽤나 흥미로웠습니다.

특히 바이브 코딩(Vibe Coding) 컨셉으로, 빠르고 즐겁게 개발하면서도 기술적인 깊이를 놓치지 않으려 노력했습니다.

## 1. 왜 Next.js 인가?

React 생태계에서 가장 성숙하고 강력한 프레임워크인 Next.js(App Router)를 선택했습니다.
블로그의 핵심인 **SEO(검색 엔진 최적화)**와 **초기 로딩 속도**를 잡기 위해 SSG(Static Site Generation) 방식이 필수적이었습니다.

## 2. 디자인 시스템: Shadcn UI

UI 라이브러리로는 요즘 가장 핫한 [shadcn/ui](https://ui.shadcn.com/)를 선택했습니다.

- **Copy & Paste 방식**: 필요한 컴포넌트만 소스 코드로 가져와서 내 입맛대로 수정할 수 있습니다.
- **Tailwind CSS 기반**: 스타일링이 매우 직관적이고 빠릅니다.
- **다크 모드**: `next-themes`와 결합하여 손쉽게 다크 모드를 구현했습니다.

## 3. 핵심 기능: 마크다운 파일 인덱싱 (O(1) 조회)

이 블로그의 백엔드 로직 중 가장 자랑하고 싶은 부분입니다.

보통의 파일 기반 블로그는 요청이 들어올 때마다 `posts` 폴더를 재귀적으로 탐색하여 글을 찾습니다. 글이 적을 땐 문제없지만, 글이 수백 개가 넘어가면 파일 I/O 비용이 급격히 증가합니다.

저는 이를 해결하기 위해 **빌드 타임 인덱싱** 전략을 도입했습니다.

### 문제점

- 매 요청마다 `fs.readdir`와 `fs.stat`을 반복 호출.
- 중첩된 카테고리 구조를 순회하는 데 시간 소요.

### 해결책: `posts-map.json`

`scripts/generate-posts-map.mjs` 스크립트를 작성하여 빌드 전(`prebuild`)에 실행되도록 했습니다.
이 스크립트는 모든 마크다운 파일을 스캔하여 하나의 거대한 JSON 맵 파일(`src/lib/posts-map.json`)을 생성합니다.

```json
{
  "building-this-blog": {
    "path": "posts/tech/building-this-blog.md",
    "title": "Next.js로 나만의 블로그 만들기",
    "props": { ... }
  },
  ...
}
```

이제 애플리케이션에서는 슬러그만 알면 **O(1)**의 시간 복잡도로 즉시 파일 경로와 메타데이터에 접근할 수 있습니다. 200개의 더미 포스트를 생성해서 테스트해봤는데 로딩 속도가 획기적으로 빨라졌습니다.

## 4. 카테고리와 태그 시스템

폴더 구조를 그대로 카테고리로 활용하는 방식을 택했습니다.
`posts/tech/hello.md` 파일은 자동으로 `tech` 카테고리에 속하게 됩니다.

또한, 메타데이터에 `tags` 필드를 추가하여 유연한 태그 시스템도 구축했습니다. `/categories` 페이지에서는 각 카테고리별 포스트 개수를 `O(1)`에 가깝게 계산하여 보여줍니다. (이미 인덱싱된 데이터가 있으니까요!)

## 5. 캐싱 전략: use cache

성능 최적화의 또 다른 핵심은 **Next.js의 캐싱 메커니즘**을 적극 활용한 것입니다.

### 빌드 타임 중복 연산 방지

블로그의 포스트가 많아질수록 빌드 시 발생하는 데이터 요청도 기하급수적으로 늘어날 수 있습니다.
이 블로그의 모든 데이터 페칭 함수에는 최상단에 `"use cache"` 지시어를 선언했습니다.

```typescript
export async function getPostBySlug(slug: string) {
  "use cache";
  cacheTag(`posts/${slug}`);
  // ...
}
```

비록 정적 배포(SSG) 방식이라 배포 시마다 캐시가 초기화되지만, **빌드 과정에서** 동일한 데이터를 여러 컴포넌트(예: 메타데이터 생성, 페이지 렌더링, 이전/다음 글 링크)에서 중복 호출할 때 불필요한 연산을 획기적으로 줄여줍니다.
또한, 추후 ISR(Incremental Static Regeneration)이나 동적 기능이 필요해질 때를 대비한 탄탄한 기반이기도 합니다.

## 6. 마치며

직접 바닥부터 블로그를 만들어보니 Next.js의 동작 원리를 더 깊게 이해할 수 있었습니다.
특히 `use cache`, `cacheTag` 같은 최신 캐싱 전략과 파일 시스템 최적화를 고민하는 과정이 즐거웠습니다.

앞으로 이 블로그에 개발 이야기와 일상을 꾸준히 기록해 보겠습니다. 지켜봐 주세요! 🚀
