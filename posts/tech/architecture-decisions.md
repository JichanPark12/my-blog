---
title: "블로그 아키텍처 의사결정: O(1) 조회 성능과 카테고리 구조"
description: "파일 시스템 기반 블로그의 성능 한계를 극복하기 위한 O(1) 인덱싱 전략과, 폴더 구조 기반 카테고리 시스템의 장단점 및 의사결정 과정을 공유합니다."
category: "tech"
tags: ["architecture", "optimization", "nextjs", "decision-record"]
---

## 1. 데이터 접근 계층 최적화: O(N)에서 O(1)로

### 문제 인식 (Problem Context)

파일 시스템 기반의 블로그(Git-based CMS)는 데이터베이스가 없기 때문에, 특정 포스트를 찾기 위해 파일 시스템을 탐색해야 합니다.

일반적인 구현 방식은 요청이 들어올 때마다 전체 파일 목록을 스캔하여 일치하는 Slug를 찾는 것입니다.
포스트 개수가 `N`개일 때, 특정 포스트를 찾기 위한 탐색 비용은 **O(N)**이 발생합니다.

더 심각한 문제는 정적 생성(Static Generation) 시점입니다.
전체 포스트 리스트를 생성하고(`generateStaticParams`), 각 포스트마다 다시 데이터를 조회(`getPostBySlug`)해야 한다면, 최악의 경우 **N x N**에 가까운 비효율적인 연산이 발생할 수 있습니다.
Next.js의 캐싱이 존재하더라도, 근본적인 탐색 로직의 비효율성은 빌드 시간을 기하급수적으로 늘리는 원인이 됩니다.

### 해결 방안: 빌드 타임 해시 맵 (Pre-computed Hash Map)

이 문제를 해결하기 위해 런타임 탐색을 제거하고, **빌드 타임에 미리 인덱스를 생성**하는 방식을 선택했습니다.

1.  **`generate-posts-map.mjs`**: 빌드 직전(`prebuild`) 실행되는 스크립트 작성.
2.  **Mapping**: 모든 마크다운 파일을 스캔하여 `{ "slug": { metadata } }` 형태의 JSON 파일 생성.
3.  **Lookup**: 애플리케이션에서는 생성된 JSON을 import하여 사용.

### 결과

이러한 구조를 통해 슬러그를 통한 포스트 접근 복잡도를 **O(1)**로 단축시켰습니다.
수백, 수천 개의 글이 쌓이더라도 조회 성능은 일정하게 유지되며, 빌드 속도 또한 획기적으로 개선되었습니다.

## 2. 카테고리 시스템: 유연함 vs 명확함

### 초기 설계: Frontmatter 기반 방식

처음에는 각 마크다운 파일의 Frontmatter에 카테고리를 명시하는 방식을 고려했습니다.

```yaml
---
title: "Hello World"
category: "tech"
---
```

이 방식은 하나의 글이 여러 카테고리를 가질 수 있거나, 폴더 구조와 무관하게 카테고리를 설정할 수 있는 유연함을 제공합니다.

### 전환: 폴더 구조 기반 방식 (Directory-as-Category)

하지만 "개인 블로그에 과연 다중 카테고리가 필요한가?"라는 질문과 함께, 관리의 복잡성을 줄이기 위해 **폴더 구조를 곧 카테고리로 매핑**하는 방식을 채택했습니다.

- **구현**: `posts/tech/abc.md` 파일은 자동으로 `tech` 카테고리로 분류.
- **제약 사항 (Trade-off)**: 하나의 글은 오직 하나의 카테고리(물리적 폴더)에만 속할 수 있음.

### 의사결정 근거

1.  **관리 편의성**: 파일의 위치가 곧 분류이므로, 직관적인 관리가 가능합니다.
2.  **데이터 정합성**: Frontmatter의 오타나 누락으로 인한 분류 오류를 원천 차단했습니다.
3.  **단순함이 최고(Simple is Best)**: 다중 분류가 필요한 경우 `tags` 필드를 활용하는 것으로 충분하다고 판단했습니다.

결과적으로 이 방식은 카테고리 시스템 구현을 매우 단순하게 만들었으며, 컨텐츠 작성 시의 고민을 줄여주었습니다.
